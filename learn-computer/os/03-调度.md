
# 处理机调度

通常进程数量大于处理机数量，所以要按照一定的算法选择一个进程，并将处理机分配给它运行，以实现进程的并发执行

**调度层次**
- 高级调度（High Level）
	- aka 作业调度、长程调度
	- 对象：作业
	- 主要用于多道批处理系统
	- 辅助外存与内存之间的调度，作业调入时会建立相应的PCB，作业调出时才撤销PCB，调入可由操作系统决定，调出由作业运行结束才调出
- 低级调度（Low Level）
	- aka 进程调度、处理机调度、短程调度
	- 最基本，用算法为进程分配处理机资源，例如几十ms一次
- 中级调度（intermediate）
	- aka 内存调度
	- 将暂时不用的进程放到外存（PCB不外放），提高内存利用率和系统吞吐量，进程状态为挂起状态，形成挂起队列

**什么时候需要进程调度？**
- 主动放弃（进程正常终止、运行过程中发生异常而终止、进程主动请求阻塞）
- 被动放弃（分给进程的时间片用完、有更紧急的事需要处理、有更高优先级的进程进入就绪队列）

**什么时候不能进行进程调度？**
- 在处理中断的过程中
- 在操作系统**内核程序临界区**中（例如PCB，注意不是普通临界区）
- 临界资源：一个时段段内各进程互斥地访问临界资源
- 临界区：访问临界资源的那段代码
- 内核程序临界区会访问就绪队列，导致其上锁
- 在原子操作过程中（原语）


**“狭义的调度”与“进程切换”的区别**
- 狭义：选择一个进程
- 广义：狭义+进程切换

**进程切换的过程需要做什么？**
- 对原来运行进程各种数据的保存
- 对新的进程各种数据的恢复

**调度方式**
- 非剥夺调度方式（非抢占式）
	- 只允许进程主动放弃处理机
- 剥夺调度方式（抢占式）
	- 进程被动放弃，可以优先处理紧急任务，适合分时操作系统、实时操作系统

## 评价指标

$周转时间=完成时间-到达时间$
$带权周转时间=周转时间/运行时间$
$等待时间=周转时间-运行时间$

1、CPU利用率

CPU利用率=CPU忙碌的时间/总时间

2、系统吞吐量

=总共完成了多少道作业/总共花费了多少时间

3、周转时间

- 周转时间（提交作业到系统——完成作业花费的时间）、平均周转时间（各作业周转时间之和/作业数）
- 带权周转时间（作业周转时间/作业实际运行的时间）≥1、平均带权周转时间（各作业带权周转时间之和/作业数）

4、等待时间

进程或作业等待处理机状态时间的和

进程：等待被服务的时间之和

作业：建立后的等待时间+作业在外存后备队列中等待的时间

5、响应时间

从用户提交请求到首次产生响应所用的时间

## [算法](../algo/00-算法简介.md)

### な作业

#### 先来先服务 FCFS

F Come F Serve，类似 FIFO

主要用于批处理 非抢占式

**结构**：作业-后备队列；进程-就绪队列
そ：公平、不会饥饿；算法简单；
き：对长作业有利、对短作业不利

#### 短作业优先 SJF

Short Job First

最短（服务时间最短）的作业优先得到服务，时间相同，先到达的先被服务

- 非抢占式【默认】（SJF）：选最短需要时间的作业先进入运行态
- 抢占式（SRTN、shortest remaining time next）：有新作业进入就绪队列或有作业完成了，考察队列中的最小需要时间的作业

在所有进程都几乎同时到达时，采用SJF调度算法的平均等待时间、平均周转时间最少（严格来说不一定，但也差不多）

若无红色前提，抢占式的短作业/进程的平均时间最少（？）

そ：“最短的”平均等待时间，平均周转时间
き：对短作业有利，对长作业不利，可能产生饥饿现象

>平均等待时间在大多数情况下是最短的

#### 优先级调度 PSA

Priority-scheduling Algorithm

#### 高响应比优先 HRRN

Highest Response Ratio Next

要综合考虑作业/进程的等待时间和要求服务的时间

在每次调度时先计算各个作业/进程的响应比，选择响应比最高的作业/进程为其服务

$响应比=（等待时间+要求服务时间）/要求服务时间 = 等待时间/要求服务时间 + 1$

非抢占式

进程主动放弃CPU时，需要该算法选取就绪队列的作业

そ：不会饥饿

### な进程

>前三者比起早期的批处理操作系统来说，由于计算机造价大幅降低，因此之后出现的交互式操作系统(包括分时操作系统、实时操作系统等)更注重系统的响应时间、公平性、平衡性等指标。而这几种算法恰好也能较好地满足交互式系统的需求。因此这三种算法适合用于交互式系统。(比如UNIX使用的就是多级反馈队列调度算法)

#### 时间片轮转算法（Round Robin）

算法思想：公平轮流地位各个进程服务，让每个进程在一定时间间隔内都可以得到响应

算法规则：按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片（如100ms）。若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列对位重新排队。

抢占式

き：响应块，适用于分时操作系统；不会饥饿
そ：由于高频率的进程切换，因此有一定的开销；不区分任务的紧急程度

(基于先来先服务)
- 时间片太大退化为FCFS、太小导致开销大

#### 优先级调度算法

算法思想：根据任务的紧急程度来决定处理顺序
（国内规定优先级数大的、优先级高）

算法规则：每个进程/作业有各自的优先级，调度时选择优先级最高的作业/进程

适用：作业/进程/IO

抢占(由任务变化)式/不可抢占均有

静态优先级：不变
动态优先级：可以变

通常：
- 系统进程优先级高于用户进程，前台进程优先级高于后台进程，操作系统更偏好I/O进程

可以从追求公平、提升资源利用率等角度考虑改变优先级

可能会饥饿

#### 多级反馈队列调度算法

Multi-leved feedback queue

算法思想：对其它算法调度的这种权衡

算法实现：
- 设置多级就绪队列，各级队列优先级从高到低，时间片从小到大。
- 新进程到达时先进入第一级队列，按照FCFS原则排队等待被分配时间片。若用完时间片进程还未结束，则进程进入下一级队列对位。如果此时已经在最下级的队列，则重新放回最下级队列末尾。
- 只有第K级队头的进程为空时，才会为K+1级对头的进程分配时间片，被抢占处理机的进程重新放回原队列队尾。

优点：对各个进程相对公平（FCFS的优点），每个新到达的进程都可以很快就得到响应（RR的优点）；短进程只用较少的时间就可以完成（SPF的优点）；不必实现估计进程的运行时间（避免用户作假）；可灵活地调整对各类进程的偏好程度，比如CPU密集型进程、IO密集型进程(拓展:可以将因I/0而阻塞的进程重新放回原队列，这样I/0型进程就可以保持较高优先级)

默认抢占式

会饥饿

####  保证调度算法

。。。

####  公平共享调度

。。。

### な实时

>ア：应参考RTOS，delay和 time_interrupt_alloc 应该严格且单个时刻的任务不重复

优先级倒置问题（priorty inversion problem）

#### 最早截止时间优先 EDF

Earliest Deadline First

#### 最低松弛度优先  LLF

Least Laxity First

## 多处理机调度

单处理机调度：优先调度哪个

与单处理机调度相比，要注意的问题
- 考虑上哪个处理机

负载均衡--尽可能让每个CPU都同等忙碌

处理机亲和性--尽量让一个进程调度到同一个CPU上运行，以发挥CPU中缓存的作用(Cache )


|     | 公共就绪队列                        | 私有就绪队列                        |
| --- | ----------------------------- | ----------------------------- |
|     | 所有CPU共享同一个就绪进程队列（需要上互斥锁）      | 每个CPU都有一个私有就绪队列               |
|     | 每个CPU时运行调度程序，从公共就绪队列中选择一个进程运行 | CPU空闲时运行调度程序，从私有就绪队列中选择一个进程运行 |
| 优点  | 天然负载均衡                        | 天然有处理机亲和性                     |
| 缺点  | 各个进程频繁地换CPU运行，“亲和性”不好         |                               |



公共就绪队列如何提升处理机亲和性?
- 软亲和:由进程调度程序尽量保证“亲和性”
- 硬亲和:由围户进程通过系统调用，主动要求亲和性”操作系统分配固定的CPU佣保“

私有就绪队列实现负载均衡
- 推迁移(Push)策略
	- 一个特定的系统程序周期性检查每个处理器的负载，如果负载不平衡，就从忙碌CPU的就绪队列中“推”一些就绪进程到空闲CPU的就绪队列
- 拉迁移(pull)策略
	- 每个CPU运行调度程序时，周期性检查自身负载与其他CPU负载。如果一个CPU负载很低，就从其他高负载CPU的就绪队列中“拉”一些就绪进程到自己的就绪队列

# 死锁 0xDEAD LOCK

进程同步、资源分配

各进程(至少2个)互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象。

饥饿：由于长期得不到想要的资源，某进程无法向前推进的现象。

死循环：某进程执行过程中一直跳不出某个循环的现象。是程序本身的问题。

死锁产生的必要条件
- 互斥条件：多个进程争夺资源发生死锁
- 不剥夺条件：进程获得的资源不能由其它进程强行抢夺
- 请求和保持条件：某个进程有了资源，还在请求资源
- 循环等待条件：存在资源的循环等待链

When 发生死锁
- 对系统资源的竞争
- 进程推进顺序非法
- 信号量的使用不当也会造成死锁

死锁的处理策略
- 预防死锁 （破坏死锁某个条件）
- 避免死锁 （银行家算法）
- 死锁的检测和解除 （允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种措施解除死锁）

### 死锁的处理策略

#### 预防死锁(静态策略)

互斥条件：只有对必须互斥使用的资源的争抢才会导致死锁。

如果把只能互斥使用的资源改造为允许共享使用，则系统不会进入死锁状态。比如：SPOOLing技术。
操作系统可以采用SPOOLing技术把独占设备在逻辑上改造成共享设备。比如，用SPOOLing技术将打
印机改造为共享设备...

- 破坏互斥条件（有些不能破坏）
	- 把互斥的资源改造为共享资源
- 破坏不剥夺条件（复杂，造成之前工作失效，降低系统开销，会全部放弃、导致饥饿）
	- 方案1：当请求得不到满足的时候，立即释放手里的资源
	- 方案2：由系统介入，强行帮助剥夺
- 破坏请求和保持条件（资源利用率极低，可能会导致某些进程饥饿）
	- 采用静态分配方法，一次性全部申请，如果申请不到，不要允许
- 破坏循环等待条件（不方便增加新的设备，实际使用与递增顺序不一致，会导致资源的浪费，必须按规定次序申请资源）
	- 顺序资源分配法：对资源编号，进程按编号递增顺序请求资源【原理分析:一个进程只有已占有小编号的资源时，才有资格申请更大编号的资源。按此规则，已持有大编号资源的进程不可能逆向地回来申请小编号的资源，从而就不会产生循环等待的现象。】

#### 避免死锁(动态检测)

- 什么是安全序列
	- 进行后面的某些情况，不会使系统发生死锁
- 什么是系统的不安全状态，与死锁有何联系
	- 如果系统处于安全状态，就一定不会发生死锁。如果系统进入不安全状态，就可能发生死锁（处于不安全状态未必就是发生了死锁，但发生死锁时一定时在不安全状态）
- 如何避免系统进入不安全状态——银行家算法
	- 初始分配完成后，优先全部分配给最少的，并且拿回资源

银行家算法步骤：
①检查此次申请是否超过了之前声明的最大需求数
②检查此时系统剩余的可用资源是否还能满足这次请求
③试探着分配，更改各数据结构
④用安全性算法检查此次分配是否会导致系统进入不安全状态

安全性算法：检查当前的剩余可用资源是否能满足某个进程的最大需求，如果可以，就把该进程加入安全序列，并把该进程持有的资源全部回收。

#### 死锁的检测和解除

死锁的检测
1、用某种数据结构来保存资源的请求和分配信息
- 资源分配图（Resource Allocation Graph）
2、提供一种算法，利用上述信息来检测系统是否已进入死锁状态

死锁的解除
1、资源剥夺法：挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。
- 关键是如何“剥夺”
2、撤销(终止)进程法：强制撤销部分，甚至全部死锁进程，并剥夺这些进程的资源。
3、进程回退法：让一个或多个死锁进程回退到足以避免死锁的地步。
- 付出代价最小的方法……


































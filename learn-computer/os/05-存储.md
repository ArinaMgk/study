
存储层次
- 寄存器
- 高速缓存
- 主存储器
- 磁盘缓存
- 固定磁盘
- 可移动存储介质

>计算机和主存储器又称为可执行存储器，这些存储器访问用 load/store 指令，对其他存储器一般使用IO操作。

**链接方式**
- 静态链接
	- （在程序运行前，先将各目标模块及它们所需的库函数连接成一个完整的可执行文件）
- 装入时动态链接
	- （将各目标模块装入内存时，边装入边链接的链接方式【一边装入指令 一边修改指令地址】）
- 运行时动态链接
	- （在程序执行中需要该模块时，才对它进行链接，其优点时便于修改和更新。）

**装入方式**
- 绝对装入
	- （在编译的时候就知道程序放在内存的哪个位置）
- 静态重定位
	- （装入时将逻辑地址转表为物理地址）
- 动态重定位
	- （把地址转化推迟到程序真正要执行时才进行）


## 分配算法

内部碎片：分配给某进程的内存区域中，如果有些部分没有用上

外部碎片：是指内存中的某些空闲分区由于太小而难以利用（如果有外部碎片，可以采用紧凑技术）

### 连续分配方式

- 单一连续分配
	- 内存被分配为系统区和用户区，系统区在低地址，用户区是一个用户独享
	- 单任务 实现简单 不实用 无外部碎片
- 固定分区分配
	- 将用户区分割为若干固定分区给各道程序，分割策略有分区大小相等和分区大小不相等，可以建立一个分区表来管理各个分区
	- 简单 不实用 无外部碎片 有内部碎片
- 动态分区分配 aka 可变分区分配
	- 不会预先划分内存分区，而是在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要。
	- 没有内部碎片 有外部碎片
	- 【基于顺序搜索的】
	- 1、首次适应算法(First Fit)
		- 每次从低地址开始查找，找到第一个能满足大小的空闲分区
	- 2、最佳适应算法(Best Fit)
		- 为了保证“大进程”到来时能有连续的大片区域，可以尽可能留下大片的空闲区，优先使用更小的空闲区。
		- 空闲分区按容量递增次序链接，分配内存时顺序查找空闲分区链
		- き：会留下小碎片
	- 3、最坏适应算法(Worst Fit)
		- 和最佳适应算法相反，按容量递减次序排列，每次尽可能用大的分区
	- 4、领近适应算法(Next Fit)
		- 每次从上次查找结束的位置开始检索
		- き：大空间容易被用完
	- 【基于索引搜索的】
		- 快速适应 (Quick Fit)
		- 伙伴系统 (Buddy System)
		- 哈希
- 动态可重定位分区分配

## Swap

覆盖技术：将程序分为多个段，内存分为”固定区“和”覆盖区“，需要常驻的放在”固定区“，调入后就不再调出，不常用的段放在”覆盖区“，需要用到时调入内存，用不到时调出内存

必须由程序员声明覆盖结构，操作系统完成自动覆盖。缺点:对用户不透明，增加了用户编程负担。覆盖技术只用于早期的操作系统中，现在已成为历史，

交换技术：内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存（PCB会常驻内存，不会被交换）

1.具有对换功能的操作系统中，通常把磁盘空间分为文件区和对换区两部分。文件区主要用于存放文件，主要追求存储空间的利用率，因此对文件区空间的管理采用离散分配方式；对换区空间只占磁盘空间的小部分，被换出的进程数据就存放在对换区。由于对换的速度直接影响到系统的整体速度，因此对换区空间的管理主要追求换入换出速度，因此通常对换区采用连续分配方式。总之，对换区的1/O速度比文件区的更快。
2.交换通常在许多进程运行且内存吃紧时进行，而系统负荷降低就暂停。例如：在发现许多进程运行时经常发生缺页，就说明内存紧张，此时可以换出一些进程；如果缺页率明显下降，就可以暂停换出。
3.可优先换出阻塞进程；可换出优先级低的进程；为了防止优先级低的进程在被调入内存后很快又被换出，有的系统还会考虑进程在内存的驻留时间...

## Segm

>與x86的分段机制不同

1、什么是分段？
进程的地址空间：按照程序自身的逻辑关系划分为若干个段，每段有段名，每段从0开始编址
段号的位数决定了每个进程最多可以分几个段
段内地址位数决定了每个段的最大长度是多少

2、什么是段表（段映射表）
每个程序被分段后，用段表记录该程序在内存中存放的位置
段表：段号 段长 基址

页：信息的物理单位，实现离散分配，提高内存利用率，地址是一维的，访存两次
段：信息的逻辑单位，对系统可见，地址是二维的，访存3次
分页：利用率高，碎片少，不方便进行信息共享和保护
分段：方便信息共享和保护，如果段长大，容易产生外部碎片

分段比分页更容易实现信息的共享和保护（不能被修改的代码称为纯代码和可重入代码，不属于临界资源）

## Page

答题：页面相对于程序，页框相对于物理内存块

**页表寄存器**（PgTabR），存放页表在内存中的起始地址F和页表长度M，进程未执行时，页表的起始地址和页表的长度放在进程控制块（PCB）中，当进程被调度时，操作系统内核会把它们放在页表寄存器中。

答题：PTR=页表基址+页表长度

- 访问内存有效时间(Effective Access Time)计算

### 快表

1、局部性原理

时间局部性：访问某个变量后，在不久的将来还会被访问
空间局部性：程序访问了某个存储单元，不久之后，其附近的存储单元也很有可能被访问

2、什么是快表（TLB）

快表：又称联想寄存器（TLB），是一种访问速度比内存快很多的高速缓冲存储器，用来存放当前访问的若干页表项，以加速地址变换的过程。与此对应，内存中的页表常称为慢表。

3、引入快表后，地址的变换过程

无快表：
①算页号、页内偏移量
②检查页号合法性
③查页表，找到页面存放的内存块号
④根据内存块号与页内偏移量得到物理地址
5访问目标内存单元

有快表：
①算页号、页内偏移量
②检查页号合法性
③查快表。若命中，即可知道页面存放的内存块号，可直接进行⑤；
若未命中则进行④
④查页表，找到页面存放的内存块号，并且将页表项复制到快表中
5根据内存块号与页内偏移量得到物理地址
6访问目标内存单元

### 多级页表

1、单级页表存在什么问题？如何解决？
所有页表项必须连续存放，页表过大时需要很大的连续空间
在一段时间内并非所有页面都用得到，因此没必要让整个页表常驻内存

2、两级页表的原理、逻辑地址结构
将长长的页表再分页
逻辑地址结构：（一级页号、二级页号、页内偏移量）
一级页表又称：页目录表、外层页表、顶级页表

3、如何实现地址变换？
按照地址结构将逻辑地址拆分成三部分
从PCB中读出页目录表始址，根据一级页号查页目录表，找到下一级页表在内存中的存放位置
根据二级页号查表，找到最终想访问的内存块号
结合页内偏移量得到物理地址

4、两级页表问题需要注意的几个细节

多级页表中，各级页表的大小不能超过一个页面。若两级页表不够，可以分更多级
多级页表的访问次数（假设没有快表结构）——N级页表访问一个逻辑地址需要N+1次访存

>MCCA 对于二级页表：页目录(L2P) 页表(L1P) 页(L0P)

### 反置页表 （Inverted Page Table）

### [页面置换算法](../algo/00-算法简介.md) 

#### 最佳置换算法（OPT）Optimal

每次选择淘汰的页面是以后永不使用或者在**未来最长时间内不再被访问**的页面，这样可以保证最低的缺页率。

实际上不知道后面的序列，因此不实际

#### 先进先出置换算法（FIFO）

每次选择淘汰的页面是最早进入内存的页面

特性：Belady异常，当分配的内存块增大时，缺页次数反而增加


#### 最近最久未使用置换算法（LRU）

每次淘汰最近最久未使用的页面

需要硬件支持 开销大

#### 时钟置换算法（最近未用算法 Not Recently Used，CLOCK）

第一轮淘汰访问位=0的，并将扫描过的页面访问位改为1。若第一轮没选中，则进行第二轮扫描。

简单的：最多经历两轮扫描

- 简单的CLOCK 算法实现方法:为每个页面设置一个访问位，再将内存中的页面都通过链接指针链接成个循环队列。当某页被访问时，其访问位置为1。当需要淘汰个页面时，只需检查页的访问位。如果是0，就选择该页换出:如果是1，则将它置为0，暂不换出，继续检查下一个页面，若第一轮打描中所有页面都是1，则将这些页面的访问位依次置为0后，再进行第二轮扫描(第二轮扫描中一定会有访问位为0的页面，因此简单的CLOCK 算法选择一个淘汰页面最多会经过两轮扫描)
- 有指针
- 仅仅置换时才用
- 实际上被访问也需要定位并且标记

页号、内存块号、状态位、访问位、修改位、外存地址

#### 改进型的时钟置换算法

若用(访问位,修改位)的形式表述，则
第一轮:淘汰(0,0)
第二轮:淘汰(0,1)，并将扫描过的页面访问位都置为0
第三轮:淘汰(0,0)
第四轮:淘汰(0,1)

优先淘汰没有被修改过的，因为没有修改过的不用进行IO操作00->01（改）->00->01

算法规则:将所有可能被置换的页面排成，个循环队列第一轮:从当前位置开始扫描到第一个(0,0)的帧用于替换。本轮扫描不修改任何标志位第二轮:若第一轮扫描失败，则重新扫描，查找第一个(0,1)的帧用于替换。本轮将所有扫描过的帧访问位设为0第三轮:若第二轮扫描失败，则重新扫描，查找第一个(0,0)的用于替换。本轮扫描不修改任何标志位第四轮:若第三轮扫描失败，则重新扫描，查找第一个(0,1)的帧用于替换
由于第二轮已将所有帧的访问位设为0，因此经过第三轮、第四轮扫描定会有一个帧被选中，因此改进型CLOCK置换算法选择一个淘汰页面最多会进行四轮扫描

#### 页面缓冲算法 （Page Buffering Algorithm）

### 页面分配

1、驻留集

指请求分页存储管理中给进程分配的物理块的集合

若驻留集太小，会导致缺页频繁，系统要花大量的时间来处理缺页，实际用于进程推进的时间很少;驻留集太大，又会导致多道程序并发度下降，资源利用率降低。所以应该选择一个合适的驻留集大小。

2、页面分配、置换策略

局部置换：选进程自己的物理块进行置换
全局置换：可以选择操作系统全局的

- 固定分配局部替换：驻留集大小不可改变
- 可变分配全局替换：开始分配一定数量，可以将操作系统保留的空闲物理块分配给缺页进程。只要某进程发生缺页，都将获得新的物理块，仅当空闲物理块用完时，系统才选择一个未锁定的页面调出。被选择调出的页可能是系统中任何一个进程中的页，因此这个被选中的进程拥有的物理块会减少，缺页率会增加。
- 可变分配局部替换：进程的物理块数目可以改变

3、调入页面的时机

预调页策略：一次调用若干个相邻页面，运行前调入
请求调页策略：运行时缺页再调入

4、从何处调页
对换区：快，采用连续分配方式
文件区：慢，采用离散分配方式

5、抖动（颠簸）现象

刚刚换出的又要换入，刚刚换入的又要换出，物理块不够

6、工作集

一般来说，驻留集大小不能小于工作集大小，否则进程运行过程中将频繁缺页。

指在某段时间间隔里，进程实际访问页面的集合


## 虚拟存储器

1、传统存储管理方式的特征、缺点
一次性：作业必须全部装入内存后才能开始运行，并发性下降
驻留性：一旦作业被装入内存，就会一直驻留在内存

2、局部性原理
- 时间局部性
- 空间局部性
- 高速缓存技术

3、虚拟内存的定义和特征
非连续分配
虚拟内存最大容量是计算机地址结构确定的
虚拟内存的实际容量=min(内存和外存容量之和，CPU寻址范围)
eg：某计算机地址结构为32位，按字节编址，内存大小为512MB，外存大小为2GB.

则虚拟内存的最大容量为 2^32B=4GB
虚拟内存的实际容量=min(2^32B,512MB+2GB)=2GB+512MB

**虚拟存储器特征**
多次性：无需在作业运行时一次性全部装入内存，而是允许被分成多次调用内存
对换性：在作业运行时无需一直常驻内存，而是允许在作业运行过程中，将作业换入换出
虚拟性：从逻辑上扩充了内存的容量，使用户看到的内存容量，远大于实际的容量

4、如何实现虚拟内存技术

在程序执行过程中，当所访问的信息不再内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序。
若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存。

### 实现方法

#### 请求分页

1、页表机制

请求分页存储的页表：

内存块号 状态位 访问字段 修改位 外存地址
- 状态位 是否在内存中
- 访问字段 存放上次访问时间等
- 修改位 调入内存后是否被修改过

2、缺页中断机构

内中断，可被修复

3、地址变换机构

>换页后注意刷新快表

>内存映射文件(Memory-Mapped Files):利用缺页中断来读文件？——20250713のア

#### 请求分段

...




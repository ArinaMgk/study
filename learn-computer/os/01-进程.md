


定义：……

组成：PCB（Proc Ctrl Block, 进程存在唯一的标志），程序段，数据段


**特征**
- 动态性 动态创建、终止
- 并发性
- 独立性
- 异步性 以不可预知的速度向前推进
- 结构性 都有PCB等数据支持

### 状态

#### 无挂起版本

**状态**(无挂起版本)
- 运行状态 Running：占有CPU，并在CPU上运行，单核只能一个进程（双核两个）（CPU√，其它资源√）
- 就绪状态 Ready：已经具备运行条件，但是没有空闲的CPU，暂时不能运行（CPUX，其它资源√）
- 阻塞状态 Block：等在某个事件的发生，暂时不能运行（CPUX，其它资源X）
- 创建状态：创建PCB，程序段，数据段
- 终止状态：回收内存，程序段，数据段，撤销PCB

>前三种是基本状态

进程状态间的转换
- **创建态->就绪态**
- 就绪态->运行态 时间片到
- 运行态->就绪态
- **运行态->中止态**（比如数组越界或正常退出）
- 运行态->阻塞态（主动）申请资源
- 阻塞态->就绪态（被动）

#### 七状态模型

挂起：部分必要数据可能在外存

引入就绪挂起、阻塞挂起

- 就绪态（活动就绪） -> 挂起 -> 就绪挂起（静态就绪）
- 就绪挂起 -> 激活 -> 就绪态
- 阻塞（活动阻塞） -> 挂起 -> 阻塞挂起（静态阻塞）
- 阻塞挂起 -> 激活 -> 阻塞态
- 运行态 -> 就绪挂起
- 创建态 -> 就绪挂起


### 进程切换

- pushad
- sp = 内核栈
- 保存原进程状态
- 应用新进程状态
- popad then iretd

### 顺序执行ゆ并发执行


|       | 顺序   | 并发    |
| ----- | ---- | ----- |
|       | 顺序性  | 间断性   |
| 受外界因素 | 封闭性  | 失去封闭性 |
|       | 可再现性 | 不可再现性 |


### 进程控制块

进程表，PCB(Process Control Block)。

作用
- 作为独立运行基本单位的标志
- 能实现间断性运行方式
- 提供进程管理所需要的信息
- 提供进程调度所需要的信息
- 实现与其他进程的同步与通信

信息
- 进程标识符 PID
- 处理机状态 各种寄存器
- 进程调度信息 —— 状态、优先级、阻塞原因
- 进程控制信息 —— 资源清单、消息队列指针、信号量

PCB整体的组织方式
- 线性方式
	- 简单、开销小、每次都要扫描整个表、适合PCB不多的情况
- 链接方式
	- 一个PCB含有指针，指向不同状态队列的下一个
- 索引方式
	- 不同状态各有一个索引表
	- >Running 可以按不同的核来编排

### 进程同步

**多道程序的制约关系**
- 间接制约 互斥访问设备等
- 直接制约 通过共同缓冲区传递数据通信等，即同步

指为了完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调他们的工作次序而产生的制约关系。进程间的直接制约关系就是源于它们之间的相互合作。

**临界资源** Critical Resource
- 把一个时间段内只允许一个进程使用的资源称为临界资源。
- 对临界资源的互斥访问，可以在逻辑上分为四个部分
	- entry section;  //进入区  对访问的资源检查或进行上锁
	- critical section; //临界区(段) 访问临界资源的那部分代码
	- exit section;   //退出区  负责解锁
	- remainder section; //剩余区  其它处理；
		- 使用操作不要放在临界区，不然并发度会降低

```c++
{
	Lock lock(res);
	res++;
	lock.~Lock();
	...;
}
```

**同步机制应遵循的规则**
1、空闲让进。 空的可以直接进去
2、忙则等待。 繁忙不能进去
3、有限等待。 不能让进程等待无限长时间
4、让权等待。 不能进去，不要堵着

#### 进程互斥实现

硬件
- x86的 BTS 和 XCHG 指令

软件
（1）单标志法

两个进程在访问完临界区后会把使用临界区的权限教给另一个进程。也就是说每个进程进入临界区的权限只能被另一个进程赋予

```c
int turn =0;
//p0进程
while(turn!=0);
critical section;
turn = 1;
remainder section;

//p1进程
while(turn!=1);
critical section;
turn = 0;
remainder section;
```

问题：p1要访问的话，必须p0先访问，违背：空闲让进原则

（2）双标志先检查

设置一个bool数组flag来标记自己是否想要进入临界区的意愿

```c
bool flag[2]={false,false};

//p1进程
while(flag[1]);
//<-- 这里发生p2进程就会有危险
flag[0]=true;
critical section;
flag[0]=false;
remainder section;

//p2进程
while(flag[0]);
flag[0]=true;
critical section;
flag[1]=false;
remainder section;
```

问题：由于进程是并发进行的，可能会违背忙则等待的原则

（3）双标志后检查

设置一个bool数组flag来标记自己是否想要进入临界区的意愿,不过是先上锁后检查

```
bool flag[2]={false,false};

//p1进程
flag[0]=true;
while(flag[1]);
critical section;
flag[0]=false;
remainder section;

//p2进程
flag[0]=true;
while(flag[0]);
critical section;
flag[1]=false;
remainder section;
```

问题：由于进程是并发进行的，可能会两个同时上锁，都进不去，违反空闲让进和有限等待原则；会饥饿

（4）Peterson 算法

主动让对方先使用处理器

```c
bool flag[2]={false,false};
int turn=0;

//p1进程
flag[0]=true;
turn=1;// 客气话，谁最后说谁被动
while(flag[1]&&turn==1);
critical section;
flag[0]=false;
remainder section;

//p2进程
flag[1]=true;
turn=0;
while(flag[0]&&turn==0);
critical section;
flag[1]=false;
remainder section;
```

遵循空闲让进、忙则等待、有限等待三个原则

但是未遵循让权等待的原则（进不了临界区就放弃，而不是轮询）

#### 信号量机制

开创者：dijkstra

>除非特别说明，默认S为记录型信号量

信号量是一种变量，表示系统中某种资源的数量

一对原语：wait（S）原语和signal（S）原语，分别简称P（S）、V（S）

wait、signal 原语常简称为P、V操作(来自荷兰语 proberen和 verhogen)。因此，做题的时候常把wait(S)、signal(s)两个操作分别写为 P(S)、V(S)

1、整形信号量

用一个整数表示系统资源的变量，用来表示系统中某种资源的数量

```
int S=1;
atom void wait(int& S){ //wait原语，相当于：进入区
  while(S<=0); //如果资源数不够，就循环等待
  S=S-1;    //如果资源数够，则占用一个资源
}
​
atom void signal(int& S){//signal原语，相当于“退出区”
  S=S+1;    //使用完资源后，在退出区释放资源
}
```

可能会出现盲等

2、记录型信号量

记录型数据结构表示的信号量

```
//记录型信号量的定义
typedef struct{
  int value;
  struct process *L;
} semaphore;
//某进程需要使用资源时，通过wait原语申请
void wait (semaphore S){
  S.value--;
  if(S.value<0){
    block (S.L);//将该进程加入到消息队列中
 }
}
//进程使用完资源后，通过signal原语释放
void signal (semaphore S){
  S.value++;
  if(S.valie<=0){
    wakeup(S.L);
 }
}
```

3、AND型信号量

一次性改变多个信号量。
- Swait(S1, S2, S3)
- Ssignal(S1, S2, S3)

信号量集
- Swait(S1,t1,d1, ..., Sn,tn,dn)
	- Si>=t1 时才会 Si-=di

#### 信号量应用


1、实现进程互斥

设置互斥信号量mutex，初值为1

对不同的临界资源需要设置不同的互斥信号量

PV必须成对出现

- 分析并发进程的关键活动，划定临界区
- 设置互斥信号量mutex，==初值为1==
- 在进入区P(mutex) - 申请资源
- 在退出区V(mutex) - 释放资源


2、实现进程同步

用信号量实现进程同步：
1.分析什么地方需要实现“同步关系”，即必须保证“一前一后”执行的两个操作（或两句代码）
2.设置同步信号量S,==初始为0==
3.在“前操作”之后执行V(S)
4.在“后操作”之前执行P(S) (P会阻塞)


3、实现进程的前驱关系

1.要为每一对前驱关系各设置一个同步变量
2.在“前操作”之后对相应的同步变量执行V操作
3.在“后操作”之前对相应的同步变量执行P操作

#### 管程 Monitors

>就是对PV、信号量等的封装

1、为什么要引入管程

PV操作容易出错、困难

2、管程的定义和基本特征

定义：

- 局部于管程的共享数据结构说明
- 对该数据结构进程操作的一组过程
- 对局部于管程的共享数据设置初始值的语句
- 管程有一个名字

基本特征：

- 局部于管程数据结构只能被局部于管程的过程所访问
- 一个进程只有通过调用管程内的过程才能进入管程访问共享数据
- 每次仅允许一个进程在管程内执行某个内部过程

心得：相当于C++的类，管程是数据放在private中，函数放在public中

1.需要在管程中定义共享数据（如生产者消费者问题的缓冲区）
2.需要在管程中定义用于访问这些共享数据的“入口”一一其实就是一些函数（如生产者消费者问题中，可以定义一个函数用于将产品放入缓冲区，再定义一个函数用于从缓冲区取出产品
3.只有通过这些特定的“入口”才能访问共享数据
4.管程中有很多“入口”，但是每次只能开放其中一个“入口”，并且只能让一个进程或线程进入（如生产者消费者问题中，各进程需要互斥地访问共享缓冲区。管程的这种特性即可保证个时间段内最多只会有一个进程在访问缓冲区。注意：这种互斥特性是由编译器负责实现的，程序员不用关心）
5.可在管程中设置条件变量及等待/唤醒操作以解决同步问题。可以让一个进程或线程在条件变量上等待（此时，该进程应先释放管程的使用权，也就是让出“入口”）：可以通过唤醒操作将等待在条件变量上的进程或线程唤醒。

拓展1：用管程解决生产者消费者问题

```c++
monitor producerconsumer
  condition full,empty;
  int count = 0;
  void insert(Item item){
    if(count == N)
      wait(full);
    count++;
    insert_item (item);
    if(count == 1)
      signal(empty);
 }
  Item remove(){
    if(count == 0)
      wait(empty);
    count--;
    if(count == N-1)
      signal(full);
    return remove_item();
 }
  end monitor;
​
//使用
producer(){
  while(1){
    item = 生产一个产品;
    producerconsumer.insert(item);
 }
}
​
consumer(){
  while(1){
    item = producerconsumer.remove();
    消费产品 item;
 }
}
```
拓展2：Java中类似于管程的机制

java中用synchronized来描述一个函数,这个函数同一时间只能被一个线程调用


#### 进程同步问题

##### 生产者-消费者问题

只有缓冲区没满时，生产者才能把产品放入缓冲区，否则必须等待

只有缓冲区不空时，消费者才能从中取出产品，否则必须等待

缓冲区是临界资源，各个进程互斥访问

实现互斥的P操作要放在实现同步的P操作之后，不然可能发生死锁

V操作不会导致进程发生阻塞的状态，所以可以交换

多生产者-多消费者模型
- 在生产-消费者问题中，如果缓冲区大小为1，那么有可能不需要设置互斥信号量就可以实现互斥访问缓冲区

##### 吸烟者问题

若一个生产者要生产多种产品（或者说会引发多种前驱事件），那么各个V操作应该放在各自对应的“事件”发生之后的位置

##### 读者-写者问题

1、允许多个读者同时对文件执行读操作
2、只允许一个写者往文件中写信息
3、任一写者在完成写操作之前不允许其他读者或写者工作
4、写者执行写操作前，应让已有的读者和写者全部退出

应用
- Rust 的不可变引用和可变引用

```c
semaphore rw=1;//用于实现对文件的互斥访问。表示当前是否有进程在访问共享文件
int count=0;//记录当前有几个读进程在访问文件
semaphore mutex=1;//用于保证对count变量的互斥访问
semaphore w=1; //用于实现“写优先”，不然写可能被很多读饿死

writer(){
  while(1){
    P（w）;
    P(rw); //写之前“加锁”
    写文件。。。
    V（rw);//写之后“解锁”
  V(w);
 }
}
​
reader(){
  while(1){
    P(w);
   P(mutex); //各读进程互斥访问count
    if(count==0) 
      P(rw); //第一个读进程的读进程数+1
    count++; //访问文件的读进程数+1
    V(mutex); 
    V(w);
    读文件...
    P(mutex); //各读进程互斥访问count
    count--; //访问文件的读进程数-1
    if(count==0)
      V(rw); //最后一个读进程负责“解锁”
    V(mutex);
 }
}
```

##### 哲学家进餐问题

The Dinning Philosophers Problem

五个人，必须拿左右的筷子才能吃饭

避免死锁发生

解决方案：
1、可以对哲学家进程施加一些限制条件，比如最多允许四个哲学家同时进餐，这样可以保证至少有一个哲学家是可以拿到左右两只筷子的。
2、要求奇数号哲学家先拿左边的筷子，然后再拿右边的筷子，而偶数号哲学家刚好相反。用这种方法可以保证如果相邻的两个奇偶号哲学家都想吃饭，那么只会有其中一个可以拿起第一只筷子，另一个会直接阻塞。这就避免了占有一只后再等待另一只的情况。
3、仅当一个哲学家左右两只筷子都可用时才允许他抓起筷子。

```c
semaphore chopstick[5]={1,1,1,1,1};
semaphore mutex = 1; //互斥地取筷子
Pi(){     //i号哲学家的进程
  while(1){
    P(mutex);
    p(chopstick[i]);   //拿右
    p(chopstick[(i+1)%5]);//拿左
    V(mutex);
    吃饭...
    V(chopstick[i]);
    V(chopstick[(i+1)%5]);
    思考...
 }
}
```


### 进程通信

#### 类型

1、共享存储 —— 共享存储器系统(Shared-Memory System)

（分配共享空间，且互斥（P、V操作）

基于数据结构的共享：固定分配（低级）
- 比如共享空间里只能放一个长度为10的数组。这种共享方式速度慢、限制多，是一种低级通信方式
基于存储区的共享：划分存储区（高级）
- 操作系统在内存中划出一块共享存储区，数据的形式、存放位置都由通信进程控制，而不是操作系统。这种共享方式速度很快，是一种高级通信方式。

2、消息传递

消息：消息头、消息体

- 直接通信方式（直接挂载消息）
- 间接通信方式（间接利用信箱发送消息）

3、管道通信

（pipe）

管道文件

只能半双工通信（同一时刻只能单向）

互斥（没写满，不能读，反之同理）

管道写满时，写被堵塞；读满时，读被阻塞。

管道中的数据一旦被读出，就彻底消失。因此，当多个进程读同一个管道时，可能会错乱。对此，通常有两种解决方案:①一个管道允许多个写进程，一个读进程(2014年408真题高教社官方案);②允许有多个写进程，多个读进程，但系统会让各个读进程轮流从管道中读数据(inux的方案)。

4、客户机-服务器系统







